<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Operation Inkwell – Infiltration</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    * {
      box-sizing: border-box;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #e9e5d8;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #111;
    }

    #gameContainer {
      display: flex;
      flex-direction: column;
      width: 100vw;
      height: 100vh;
    }

    #gameArea {
      position: relative;
      flex: 1 1 auto;
      width: 100%;
      overflow: hidden;
      background: #f4f2ea;
      border-bottom: 1px solid #c0b9aa;
    }

    #gameCanvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    #touchControlsBar {
      flex: 0 0 auto;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0.7rem 0.5rem;
    }

    #touchControls {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0.6rem;
      width: 100%;
      max-width: 500px;
      margin: 0 auto;
    }

    .ctrl-row {
      display: flex;
      justify-content: center;
      gap: 0.8rem;
      width: 100%;
    }

    .ctrl-btn {
      flex: 1 1 auto;
      min-width: 4.3rem;
      min-height: 4.3rem;
      border-radius: 1.2rem;
      border: 1px solid #857d6a;
      background: #fdfbf6;
      color: #111;
      font-size: 1.2rem;
      font-weight: 600;
      padding: 0.4rem 0.6rem;
      cursor: pointer;
      touch-action: none;
    }

    .ctrl-btn.wide {
      min-width: 6rem;
      font-size: 1.05rem;
    }

    .ctrl-btn:active {
      background: #e4decf;
    }

    .ctrl-btn.disabled {
      opacity: 0.4;
      border-style: dashed;
      cursor: default;
    }

    @media (min-width: 900px) {
      .ctrl-btn {
        min-width: 4rem;
        min-height: 4rem;
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <div id="gameArea">
      <canvas id="gameCanvas"></canvas>
    </div>

    <div id="touchControlsBar">
      <div id="touchControls">
        <div class="ctrl-row">
          <button id="btnUp" class="ctrl-btn">▲</button>
        </div>
        <div class="ctrl-row">
          <button id="btnLeft" class="ctrl-btn">◀</button>
          <button id="btnDown" class="ctrl-btn">▼</button>
          <button id="btnRight" class="ctrl-btn">▶</button>
        </div>
        <div class="ctrl-row">
          <button id="btnAction" class="ctrl-btn wide">ACTION</button>
          <button id="btnSound" class="ctrl-btn wide">SOUND</button>
          <button id="btnNew" class="ctrl-btn wide">NEW</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ===== Canvas & grid setup =====
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const GRID_COLS = 15;
    const GRID_ROWS = 15;
    let cellSize = 24;
    let gridOffsetX = 0;
    let gridOffsetY = 0;

    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;

      const cw = canvas.width / GRID_COLS;
      const ch = canvas.height / GRID_ROWS;
      cellSize = Math.floor(Math.min(cw, ch));

      const boardWidth = cellSize * GRID_COLS;
      const boardHeight = cellSize * GRID_ROWS;
      gridOffsetX = Math.floor((canvas.width - boardWidth) / 2);
      gridOffsetY = Math.floor((canvas.height - boardHeight) / 2);
    }

    window.addEventListener("resize", resizeCanvas);

    function gridToCenter(col, row) {
      return {
        x: gridOffsetX + col * cellSize + cellSize / 2,
        y: gridOffsetY + row * cellSize + cellSize / 2
      };
    }

    // ===== Campaign levels (hand-made) =====
    const CAMPAIGN_LEVELS = [
      [ // Mission 1
        "###############",
        "#P..#....K...X#",
        "#..##.###.##..#",
        "#..B..#...#...#",
        "#..##.#C..#...#",
        "#.....#...#...#",
        "###.#.###.###.#",
        "#...#.......#.#",
        "#..###.###.#..#",
        "#..#.......#..#",
        "#..#.C.B..##..#",
        "#..#...#......#",
        "#..###.#.##..##",
        "#.............#",
        "###############"
      ],
      [ // Mission 2
        "###############",
        "#P..#.....G..K#",
        "#..##.###.##..#",
        "#..B..#...#...#",
        "#..##.#C..#K..#",
        "#.....#...#...#",
        "###.#.###.###.#",
        "#K..#...C..#..#",
        "#..###.###.#R.#",
        "#..#.......#..#",
        "#..#.C.B..D##X#",
        "#..#...#......#",
        "#..###.#.##..##",
        "#......S......#",
        "###############"
      ],
      [ // Mission 3
        "###############",
        "#P..#..K....X.#",
        "#..##.###.##..#",
        "#..B..#...#..K#",
        "#..##.#C..#...#",
        "#.....#...#...#",
        "###.#.###.###.#",
        "#..K#...C..#..#",
        "#..###.###.#R.#",
        "#..#....G..#..#",
        "#..#.C.B..D##.#",
        "#..#...#...S..#",
        "#..###.#.##..##",
        "#......B......#",
        "###############"
      ]
    ];

    // ===== Random base templates (walls, player, exit only) =====
    const RANDOM_TEMPLATES = [
      [
        "###############",
        "#P....#.......#",
        "#.....#..X....#",
        "#.....#####...#",
        "#.............#",
        "#..###..###...#",
        "#..#.......#..#",
        "#..#.......#..#",
        "#..###..###...#",
        "#.............#",
        "#...#####.....#",
        "#.............#",
        "#.....#.......#",
        "#.....#.......#",
        "###############"
      ],
      [
        "###############",
        "#P..#.....X...#",
        "#...#.........#",
        "#...#..#####..#",
        "#...#.........#",
        "#...#####.....#",
        "#.............#",
        "#..###...###..#",
        "#..#.......#..#",
        "#..#.......#..#",
        "#..###...###..#",
        "#.............#",
        "#.....#####...#",
        "#.............#",
        "###############"
      ],
      [
        "###############",
        "#P..#.........#",
        "#...#..###....#",
        "#...#..#X#....#",
        "#...#..###....#",
        "#.............#",
        "#..####...###.#",
        "#.............#",
        "#.###...####..#",
        "#.............#",
        "#....###...###.",
        "#.............#",
        "#....#........#",
        "#....#........#",
        "###############"
      ]
    ];

    function randInt(min, max) {
      return min + Math.floor(Math.random() * (max - min + 1));
    }

    function generateRandomLayout() {
      const base = RANDOM_TEMPLATES[randInt(0, RANDOM_TEMPLATES.length - 1)];
      const grid = base.map(row => row.split(""));

      const floors = [];
      for (let r = 0; r < GRID_ROWS; r++) {
        for (let c = 0; c < GRID_COLS; c++) {
          const ch = grid[r][c];
          if (ch === ".") {
            floors.push({ col: c, row: r });
          }
        }
      }

      function placeChar(ch, count) {
        for (let i = 0; i < count && floors.length > 0; i++) {
          const idx = Math.floor(Math.random() * floors.length);
          const spot = floors.splice(idx, 1)[0];
          grid[spot.row][spot.col] = ch;
        }
      }

      placeChar("K", randInt(2, 4)); // intel
      placeChar("B", randInt(2, 5)); // barrels
      placeChar("C", randInt(2, 5)); // crates
      placeChar("G", randInt(1, 3)); // patrol guards
      placeChar("S", randInt(0, 2)); // stationary guards
      placeChar("R", randInt(1, 3)); // cameras

      return grid.map(row => row.join(""));
    }

    const TILE_WALL  = "#";
    const TILE_FLOOR = ".";
    const TILE_DOOR  = "D";
    const TILE_EXIT  = "X";

    // Mission index (0.. campaign, then infinite random)
    let currentMission = 0;
    let currentLayout = null; // array of strings for this mission

    // ===== Game state =====
    let baseMap = [];
    let player = {
      col: 1,
      row: 1,
      dir: { x: 0, y: -1 },
      alive: true,
      won: false
    };

    let guards = [];     // includes cameras as type "camera"
    let barrels = [];
    let crates = [];
    let explosions = [];
    let intel = []; // {col,row,collected}

    let message = "";
    let messageTimer = 0;

    const keys = {
      up: false,
      down: false,
      left: false,
      right: false,
      wait: false,
      action: false
    };

    // ===== Layout selection =====
    function buildMissionLayout(index) {
      if (index < CAMPAIGN_LEVELS.length) {
        return CAMPAIGN_LEVELS[index];
      }
      return generateRandomLayout();
    }

    // ===== Level loading =====
    function resetLevel(isNewMission = false) {
      if (isNewMission || !currentLayout) {
        currentLayout = buildMissionLayout(currentMission);
      }
      const level = currentLayout;

      baseMap = [];
      guards = [];
      barrels = [];
      crates = [];
      explosions = [];
      intel = [];
      player.alive = true;
      player.won = false;
      message = "";
      messageTimer = 0;

      for (let r = 0; r < GRID_ROWS; r++) {
        baseMap[r] = [];
        const rowStr = level[r];
        for (let c = 0; c < GRID_COLS; c++) {
          const ch = rowStr[c];
          let tile = TILE_FLOOR;

          if (ch === "#") tile = TILE_WALL;
          else if (ch === "D") tile = TILE_DOOR;
          else if (ch === "X") tile = TILE_EXIT;

          if (ch === "P") {
            player.col = c;
            player.row = r;
            player.dir = { x: 0, y: -1 };
          } else if (ch === "G") {
            guards.push({
              col: c,
              row: r,
              type: "patrol",
              dirX: 1,
              dirY: 0,
              mode: "normal",
              soundTarget: null
            });
          } else if (ch === "S") {
            guards.push({
              col: c,
              row: r,
              type: "stationary",
              facing: { x: 0, y: -1 },
              mode: "normal",
              soundTarget: null
            });
          } else if (ch === "R") {
            guards.push({
              col: c,
              row: r,
              type: "camera",
              facingIndex: 0
            });
          } else if (ch === "B") {
            barrels.push({ col: c, row: r });
          } else if (ch === "C") {
            crates.push({ col: c, row: r });
          } else if (ch === "K") {
            intel.push({ col: c, row: r, collected: false });
          }

          baseMap[r][c] = tile;
        }
      }

      const inCampaign = currentMission < CAMPAIGN_LEVELS.length;
      const missionLabel = inCampaign
        ? "Mission " + (currentMission + 1)
        : "Random op " + (currentMission - CAMPAIGN_LEVELS.length + 1);
      showMessage(missionLabel, 2);
      updateButtons();
    }

    function nextLevel() {
      currentMission++;
      currentLayout = null;
      resetLevel(true);
    }

    // ===== Helpers =====
    function inBounds(col, row) {
      return col >= 0 && col < GRID_COLS && row >= 0 && row < GRID_ROWS;
    }

    function tileAt(col, row) {
      if (!inBounds(col, row)) return TILE_WALL;
      return baseMap[row][col];
    }

    function isWallLike(col, row) {
      return tileAt(col, row) === TILE_WALL;
    }

    function guardAt(col, row) {
      for (let i = 0; i < guards.length; i++) {
        if (guards[i].col === col && guards[i].row === row) return guards[i];
      }
      return null;
    }

    function findBarrel(col, row) {
      for (let i = 0; i < barrels.length; i++) {
        const b = barrels[i];
        if (b.col === col && b.row === row) return b;
      }
      return null;
    }

    function removeBarrel(b) {
      const idx = barrels.indexOf(b);
      if (idx >= 0) barrels.splice(idx, 1);
    }

    function findCrate(col, row) {
      for (let i = 0; i < crates.length; i++) {
        const c = crates[i];
        if (c.col === col && c.row === row) return c;
      }
      return null;
    }

    function removeCrate(c) {
      const idx = crates.indexOf(c);
      if (idx >= 0) crates.splice(idx, 1);
    }

    function clearDoorAt(col, row) {
      if (!inBounds(col, row)) return;
      if (baseMap[row][col] === TILE_DOOR) baseMap[row][col] = TILE_FLOOR;
    }

    function isBlockedForPlayer(col, row) {
      const t = tileAt(col, row);
      if (t === TILE_WALL || t === TILE_DOOR) return true;
      if (findCrate(col, row)) return true;
      if (findBarrel(col, row)) return true;
      const g = guardAt(col, row);
      if (g && g.type !== "camera") return true;
      return false;
    }

    function isBlockedForPush(col, row) {
      const t = tileAt(col, row);
      if (t === TILE_WALL || t === TILE_DOOR) return true;
      if (findCrate(col, row)) return true;
      if (findBarrel(col, row)) return true;
      const g = guardAt(col, row);
      if (g && g.type !== "camera") return true;
      return false;
    }

    function showMessage(text, timeSec) {
      message = text;
      messageTimer = timeSec;
    }

    function allIntelCollected() {
      if (intel.length === 0) return true;
      return intel.every(i => i.collected);
    }

    function pickupIntelIfAny() {
      for (let i = 0; i < intel.length; i++) {
        const itm = intel[i];
        if (!itm.collected && itm.col === player.col && itm.row === player.row) {
          itm.collected = true;
          const collected = intel.filter(k => k.collected).length;
          showMessage("Intel " + collected + "/" + intel.length + " secured.", 2);
        }
      }
    }

    function canUseActionHere() {
      const dirs = [
        { x: 1, y: 0 }, { x: -1, y: 0 },
        { x: 0, y: 1 }, { x: 0, y: -1 }
      ];
      for (let i = 0; i < dirs.length; i++) {
        const nx = player.col + dirs[i].x;
        const ny = player.row + dirs[i].y;
        if (findBarrel(nx, ny)) return true;
      }
      return false;
    }

    function updateButtons() {
      const actionBtn = document.getElementById("btnAction");
      const soundBtn  = document.getElementById("btnSound");

      if (actionBtn) {
        const usable = canUseActionHere() && player.alive && !player.won;
        actionBtn.disabled = !usable;
        if (usable) actionBtn.classList.remove("disabled");
        else actionBtn.classList.add("disabled");
      }

      if (soundBtn) {
        const usable = guards.some(g => g.type !== "camera") && player.alive && !player.won;
        soundBtn.disabled = !usable;
        if (usable) soundBtn.classList.remove("disabled");
        else soundBtn.classList.add("disabled");
      }
    }

    // ===== Guard luring helper (used by SOUND and explosions) =====
    function lureNearestGuardTo(tx, ty) {
      let bestGuard = null;
      let bestDist = Infinity;
      for (let i = 0; i < guards.length; i++) {
        const g = guards[i];
        if (g.type === "camera") continue;
        const d = Math.abs(g.col - tx) + Math.abs(g.row - ty);
        if (d < bestDist) {
          bestDist = d;
          bestGuard = g;
        }
      }
      if (!bestGuard) return false;
      bestGuard.mode = "sound";
      bestGuard.soundTarget = { col: tx, row: ty };
      return true;
    }

    // ===== Turn system =====
    function performTurn(action) {
      if (!player.alive || player.won) return;

      let moved = false;
      if (action === "move") {
        const dx = keys.right ? 1 : keys.left ? -1 : 0;
        const dy = keys.down ? 1 : keys.up ? -1 : 0;
        if (dx !== 0 || dy !== 0) {
          player.dir = { x: dx, y: dy };
          moved = tryMovePlayer(dx, dy);
        }
      } else if (action === "wait") {
        moved = true;
      } else if (action === "action") {
        doPlayerAction();
        moved = true;
      }

      keys.up = keys.down = keys.left = keys.right = false;
      keys.wait = keys.action = false;
      if (!moved) {
        updateButtons();
        return;
      }

      pickupIntelIfAny();
      stepGuards();
      checkDetection();

      if (!player.alive) {
        updateButtons();
        return;
      }
      if (tileAt(player.col, player.row) === TILE_EXIT) {
        if (allIntelCollected()) {
          player.won = true;
          const inCampaign = currentMission < CAMPAIGN_LEVELS.length;
          const lastCampaign = currentMission === CAMPAIGN_LEVELS.length - 1;
          if (inCampaign && !lastCampaign) {
            showMessage("Mission complete! NEW → next.", 4);
          } else if (lastCampaign) {
            showMessage("Campaign complete! NEW → random ops.", 4);
          } else {
            showMessage("Op complete! NEW → new layout.", 4);
          }
        } else {
          showMessage("Collect all intel first!", 2.5);
        }
      }

      updateButtons();
    }

    function tryMovePlayer(dx, dy) {
      if (dx === 0 && dy === 0) return false;
      const targetCol = player.col + dx;
      const targetRow = player.row + dy;
      if (!inBounds(targetCol, targetRow)) return false;

      const crate = findCrate(targetCol, targetRow);
      const barrel = findBarrel(targetCol, targetRow);
      if (crate || barrel) {
        const pushCol = targetCol + dx;
        const pushRow = targetRow + dy;
        if (!inBounds(pushCol, pushRow)) return false;
        if (isBlockedForPush(pushCol, pushRow)) return false;
        if (crate) { crate.col = pushCol; crate.row = pushRow; }
        else { barrel.col = pushCol; barrel.row = pushRow; }
        player.col = targetCol;
        player.row = targetRow;
        return true;
      }

      if (isBlockedForPlayer(targetCol, targetRow)) return false;
      player.col = targetCol;
      player.row = targetRow;
      return true;
    }

    function doPlayerAction() {
      if (!player.alive || player.won) return;
      let detonated = false;
      const dirs = [
        { x: 1, y: 0 }, { x: -1, y: 0 },
        { x: 0, y: 1 }, { x: 0, y: -1 }
      ];
      for (let i = 0; i < dirs.length; i++) {
        const nx = player.col + dirs[i].x;
        const ny = player.row + dirs[i].y;
        const b = findBarrel(nx, ny);
        if (b) {
          createExplosionAt(nx, ny);
          detonated = true;
        }
      }
      if (!detonated) showMessage("No barrel next to you.", 1.5);
    }

    // ===== Sound lure =====
    function makeSound() {
      if (!player.alive || player.won) return;
      const ok = lureNearestGuardTo(player.col, player.row);
      if (ok) showMessage("Clink! Someone's coming...", 1.5);
      updateButtons();
    }

    function createExplosionAt(col, row) {
      const p = gridToCenter(col, row);
      explosions.push({ x: p.x, y: p.y, age: 0, duration: 0.5, col, row });

      for (let ry = row - 1; ry <= row + 1; ry++) {
        for (let rx = col - 1; rx <= col + 1; rx++) {
          if (!inBounds(rx, ry)) continue;
          const b = findBarrel(rx, ry); if (b) removeBarrel(b);
          const c = findCrate(rx, ry);  if (c) removeCrate(c);
          clearDoorAt(rx, ry);
          const g = guardAt(rx, ry);
          if (g) {
            const idx = guards.indexOf(g);
            if (idx >= 0) guards.splice(idx, 1);
          }
        }
      }

      // After the blast, lure the nearest remaining (non-camera) guard
      const lured = lureNearestGuardTo(col, row);
      if (lured) showMessage("Boom! A guard investigates.", 1.5);
    }

    function updateExplosions(dt) {
      for (let i = explosions.length - 1; i >= 0; i--) {
        explosions[i].age += dt;
        if (explosions[i].age > explosions[i].duration) explosions.splice(i, 1);
      }
    }

    function isBlockedForGuard(col, row) {
      const t = tileAt(col, row);
      if (t === TILE_WALL || t === TILE_DOOR) return true;
      if (findCrate(col, row)) return true;
      if (findBarrel(col, row)) return true;
      return false;
    }

    function stepGuards() {
      for (let i = 0; i < guards.length; i++) {
        const g = guards[i];

        if (g.type === "camera") {
          // rotate through 8 directions
          g.facingIndex = (g.facingIndex + 1) % 8;
          continue;
        }

        // Sound-driven movement overrides normal behaviour
        if (g.mode === "sound" && g.soundTarget) {
          const tx = g.soundTarget.col;
          const ty = g.soundTarget.row;

          if (g.col === tx && g.row === ty) {
            g.mode = "normal";
            g.soundTarget = null;
            continue;
          }

          let dx = Math.sign(tx - g.col);
          let dy = Math.sign(ty - g.row);
          let moved = false;

          if (dx !== 0 && !isBlockedForGuard(g.col + dx, g.row)) {
            g.col += dx;
            if (g.type === "patrol") g.dirX = dx;
            moved = true;
          } else if (dy !== 0 && !isBlockedForGuard(g.col, g.row + dy)) {
            g.row += dy;
            moved = true;
          }

          if (!moved) {
            g.mode = "normal";
            g.soundTarget = null;
          }
          continue;
        }

        // Normal patterns
        if (g.type === "patrol") {
          let nextCol = g.col + g.dirX;
          if (!inBounds(nextCol, g.row) || isWallLike(nextCol, g.row) || isBlockedForGuard(nextCol, g.row)) {
            g.dirX *= -1;
            nextCol = g.col + g.dirX;
          }
          if (!isBlockedForGuard(nextCol, g.row)) g.col = nextCol;
        } else if (g.type === "stationary") {
          // stationary guard just looks in one direction for now
        }
      }

      for (let i = 0; i < guards.length; i++) {
        const g = guards[i];
        if (g.type !== "camera" && g.col === player.col && g.row === player.row) {
          player.alive = false;
          showMessage("You were caught!", 4);
          return;
        }
      }
    }

    // ===== Detection & FOV =====
    function rayDetectsPlayer(startCol, startRow, dx, dy, maxDist) {
      let col = startCol, row = startRow;
      for (let step = 0; step < maxDist; step++) {
        col += dx; row += dy;
        if (!inBounds(col, row)) return false;
        const t = tileAt(col, row);
        if (t === TILE_WALL || t === TILE_DOOR) return false;
        if (findCrate(col, row) || findBarrel(col, row)) return false;
        if (col === player.col && row === player.row) return true;
      }
      return false;
    }

    function checkDetection() {
      if (!player.alive) return;

      const cameraDirs = [
        { x: 0,  y: -1 },
        { x: 1,  y: -1 },
        { x: 1,  y: 0  },
        { x: 1,  y: 1  },
        { x: 0,  y: 1  },
        { x: -1, y: 1  },
        { x: -1, y: 0  },
        { x: -1, y: -1 }
      ];

      for (let i = 0; i < guards.length; i++) {
        const g = guards[i];

        if (g.type === "patrol") {
          if (rayDetectsPlayer(g.col, g.row, g.dirX, 0, 4)) {
            player.alive = false;
            showMessage("Spotted by patrol!", 4);
            return;
          }
        } else if (g.type === "stationary") {
          const fx = g.facing.x, fy = g.facing.y;
          if (rayDetectsPlayer(g.col, g.row, fx, fy, 5)) {
            player.alive = false;
            showMessage("Guard spotted you!", 4);
            return;
          }
        } else if (g.type === "camera") {
          const d = cameraDirs[g.facingIndex];
          if (rayDetectsPlayer(g.col, g.row, d.x, d.y, 6)) {
            player.alive = false;
            showMessage("Camera alarm!", 4);
            return;
          }
        }
      }
    }

    function drawGuardFOV() {
      ctx.save();
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = "#777";

      const cameraDirs = [
        { x: 0,  y: -1 },
        { x: 1,  y: -1 },
        { x: 1,  y: 0  },
        { x: 1,  y: 1  },
        { x: 0,  y: 1  },
        { x: -1, y: 1  },
        { x: -1, y: 0  },
        { x: -1, y: -1 }
      ];

      for (let i = 0; i < guards.length; i++) {
        const g = guards[i];
        let dx = 0, dy = 0, maxDist = 0;

        if (g.type === "patrol") {
          dx = g.dirX; dy = 0; maxDist = 4;
        } else if (g.type === "stationary") {
          dx = g.facing.x; dy = g.facing.y; maxDist = 5;
        } else if (g.type === "camera") {
          const d = cameraDirs[g.facingIndex];
          dx = d.x; dy = d.y; maxDist = 6;
        } else {
          continue;
        }

        let col = g.col;
        let row = g.row;
        for (let step = 0; step < maxDist; step++) {
          col += dx;
          row += dy;
          if (!inBounds(col, row)) break;
          const t = tileAt(col, row);
          if (t === TILE_WALL || t === TILE_DOOR) break;
          if (findCrate(col, row) || findBarrel(col, row)) break;

          const x = gridOffsetX + col * cellSize;
          const y = gridOffsetY + row * cellSize;
          ctx.fillRect(x, y, cellSize, cellSize);
        }
      }

      ctx.restore();
    }

    // ===== Input handling =====
    document.addEventListener("keydown", (e) => {
      let handled = false;
      if (e.key === "ArrowUp" || e.key === "w" || e.key === "W") {
        keys.up = true; handled = true; performTurn("move");
      } else if (e.key === "ArrowDown" || e.key === "s" || e.key === "S") {
        keys.down = true; handled = true; performTurn("move");
      } else if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") {
        keys.left = true; handled = true; performTurn("move");
      } else if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") {
        keys.right = true; handled = true; performTurn("move");
      } else if (e.key === " ") {
        keys.action = true; handled = true; performTurn("action");
      } else if (e.key === "Enter") {
        keys.wait = true; handled = true; performTurn("wait");
      } else if (e.key === "m" || e.key === "M") {
        handled = true;
        makeSound();
        stepGuards();
        checkDetection();
        updateButtons();
      } else if (e.key === "n" || e.key === "N") {
        handled = true;
        if (player.won) nextLevel();
        else resetLevel(false);
      }
      if (handled) e.preventDefault();
    });

    function bindTouchButton(id, handler) {
      const btn = document.getElementById(id);
      if (!btn) return;
      const down = (ev) => { ev.preventDefault(); handler(); };
      btn.addEventListener("touchstart", down, { passive: false });
      btn.addEventListener("mousedown", down);
    }

    bindTouchButton("btnUp",   () => { keys.up = true; performTurn("move"); });
    bindTouchButton("btnDown", () => { keys.down = true; performTurn("move"); });
    bindTouchButton("btnLeft", () => { keys.left = true; performTurn("move"); });
    bindTouchButton("btnRight",() => { keys.right = true; performTurn("move"); });

    bindTouchButton("btnAction", () => {
      if (canUseActionHere() && player.alive && !player.won) {
        doPlayerAction();
        pickupIntelIfAny();
        stepGuards();
        checkDetection();
        updateButtons();
      }
    });

    bindTouchButton("btnSound", () => {
      makeSound();
      if (player.alive && !player.won) {
        stepGuards();
        checkDetection();
      }
      updateButtons();
    });

    bindTouchButton("btnNew", () => {
      if (player.won) nextLevel();
      else resetLevel(false);
    });

    // ===== Rendering =====
    function drawGrid() {
      ctx.strokeStyle = "#d5cfbf";
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let c = 0; c <= GRID_COLS; c++) {
        const x = gridOffsetX + c * cellSize + 0.5;
        ctx.moveTo(x, gridOffsetY);
        ctx.lineTo(x, gridOffsetY + GRID_ROWS * cellSize);
      }
      for (let r = 0; r <= GRID_ROWS; r++) {
        const y = gridOffsetY + r * cellSize + 0.5;
        ctx.moveTo(gridOffsetX, y);
        ctx.lineTo(gridOffsetX + GRID_COLS * cellSize, y);
      }
      ctx.stroke();
    }

    function drawTiles() {
      for (let r = 0; r < GRID_ROWS; r++) {
        for (let c = 0; c < GRID_COLS; c++) {
          const t = baseMap[r][c];
          const x = gridOffsetX + c * cellSize;
          const y = gridOffsetY + r * cellSize;
          if (t === TILE_WALL) {
            ctx.fillStyle = "#c2b59a";
            ctx.fillRect(x, y, cellSize, cellSize);
          } else if (t === TILE_DOOR) {
            ctx.fillStyle = "#b89b7c";
            ctx.fillRect(x + 2, y + 2, cellSize - 4, cellSize - 4);
          } else if (t === TILE_EXIT) {
            ctx.fillStyle = "#d6e2d2";
            ctx.fillRect(x + 2, y + 2, cellSize - 4, cellSize - 4);
            ctx.strokeStyle = "#3c5f3c";
            ctx.strokeRect(x + 2, y + 2, cellSize - 4, cellSize - 4);
          }
        }
      }
    }

    function drawCrates() {
      ctx.lineWidth = 1.5;
      for (let i = 0; i < crates.length; i++) {
        const c = crates[i];
        const p = gridToCenter(c.col, c.row);
        const s = cellSize * 0.7;
        ctx.fillStyle = "#8b6f4f";
        ctx.strokeStyle = "#4f3823";
        ctx.beginPath();
        ctx.rect(p.x - s / 2, p.y - s / 2, s, s);
        ctx.fill();
        ctx.stroke();
      }
    }

    function drawBarrels() {
      ctx.lineWidth = 1.5;
      for (let i = 0; i < barrels.length; i++) {
        const b = barrels[i];
        const p = gridToCenter(b.col, b.row);
        const r = cellSize * 0.33;

        // Dark drum
        ctx.beginPath();
        ctx.fillStyle = "#333";
        ctx.strokeStyle = "#111";
        ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Horizontal bands so it reads as a barrel
        ctx.strokeStyle = "#777";
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(p.x - r * 0.8, p.y - r * 0.4);
        ctx.lineTo(p.x + r * 0.8, p.y - r * 0.4);
        ctx.moveTo(p.x - r * 0.8, p.y + r * 0.4);
        ctx.lineTo(p.x + r * 0.8, p.y + r * 0.4);
        ctx.stroke();
      }
    }

    function drawIntel() {
      ctx.lineWidth = 1.3;
      for (let i = 0; i < intel.length; i++) {
        const itm = intel[i];
        if (itm.collected) continue;
        const p = gridToCenter(itm.col, itm.row);
        const s = cellSize * 0.55;
        ctx.fillStyle = "#f7f0d0";
        ctx.strokeStyle = "#7b6a3f";
        ctx.beginPath();
        ctx.rect(p.x - s / 2, p.y - s / 2, s, s);
        ctx.fill();
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(p.x - s * 0.25, p.y);
        ctx.lineTo(p.x + s * 0.25, p.y);
        ctx.moveTo(p.x, p.y - s * 0.25);
        ctx.lineTo(p.x, p.y + s * 0.25);
        ctx.stroke();
      }
    }

    function drawGuards() {
      ctx.lineWidth = 1.2;
      for (let i = 0; i < guards.length; i++) {
        const g = guards[i];
        const p = gridToCenter(g.col, g.row);

        if (g.type === "camera") {
          // Camera: dome on a stalk
          const bodyW = cellSize * 0.7;
          const bodyH = cellSize * 0.35;

          // Stalk
          ctx.strokeStyle = "#444";
          ctx.beginPath();
          ctx.moveTo(p.x, p.y + bodyH * 0.6);
          ctx.lineTo(p.x, p.y + bodyH * 1.2);
          ctx.stroke();

          // Dome
          ctx.fillStyle = "#888";
          ctx.strokeStyle = "#333";
          ctx.beginPath();
          ctx.moveTo(p.x - bodyW / 2, p.y + bodyH / 2);
          ctx.lineTo(p.x + bodyW / 2, p.y + bodyH / 2);
          ctx.quadraticCurveTo(p.x, p.y - bodyH / 2, p.x - bodyW / 2, p.y + bodyH / 2);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();

          // Lens
          ctx.beginPath();
          ctx.fillStyle = "#222";
          const lensR = cellSize * 0.12;
          ctx.arc(p.x + bodyW * 0.15, p.y, lensR, 0, Math.PI * 2);
          ctx.fill();
        } else {
          // Normal guard: blocky body
          const w = cellSize * 0.7;
          const h = cellSize * 0.7;
          ctx.fillStyle = "#333";
          ctx.strokeStyle = "#111";
          ctx.beginPath();
          ctx.rect(p.x - w / 2, p.y - h / 2, w, h);
          ctx.fill();
          ctx.stroke();

          // visor stripe
          ctx.beginPath();
          ctx.strokeStyle = "#eee";
          ctx.moveTo(p.x - w * 0.3, p.y);
          ctx.lineTo(p.x + w * 0.3, p.y);
          ctx.stroke();
        }
      }
    }

    function drawPlayer() {
      if (!player.alive && !player.won) return;
      const p = gridToCenter(player.col, player.row);
      const size = cellSize * 0.7;
      ctx.fillStyle = player.won ? "#3d7a3d" : "#264653";
      ctx.strokeStyle = "#11202a";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      if (player.dir.y === -1) {
        ctx.moveTo(p.x, p.y - size / 2);
        ctx.lineTo(p.x - size / 2, p.y + size / 2);
        ctx.lineTo(p.x + size / 2, p.y + size / 2);
      } else if (player.dir.y === 1) {
        ctx.moveTo(p.x, p.y + size / 2);
        ctx.lineTo(p.x - size / 2, p.y - size / 2);
        ctx.lineTo(p.x + size / 2, p.y - size / 2);
      } else if (player.dir.x === -1) {
        ctx.moveTo(p.x - size / 2, p.y);
        ctx.lineTo(p.x + size / 2, p.y - size / 2);
        ctx.lineTo(p.x + size / 2, p.y + size / 2);
      } else {
        ctx.moveTo(p.x + size / 2, p.y);
        ctx.lineTo(p.x - size / 2, p.y - size / 2);
        ctx.lineTo(p.x - size / 2, p.y + size / 2);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }

    function drawExplosions() {
      for (let i = 0; i < explosions.length; i++) {
        const ex = explosions[i];
        const t = ex.age / ex.duration;
        const radius = cellSize * (0.8 + t);
        ctx.save();
        ctx.globalAlpha = 0.35 * (1 - t);
        ctx.fillStyle = "#444";
        ctx.beginPath();
        ctx.arc(ex.x, ex.y, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    function drawHUD() {
      ctx.fillStyle = "#111";
      ctx.font = "13px system-ui, sans-serif";
      ctx.textBaseline = "top";
      const lines = [
        "Triangle = you. Intel = square+cross.",
        "Crates/barrels block vision. ACTION = explode barrel.",
        "SOUND lures a guard. NEW: restart / next (random after 3)."
      ];
      let y = 6;
      for (let i = 0; i < lines.length; i++) {
        ctx.fillText(lines[i], 10, y);
        y += 14;
      }

      if (messageTimer > 0 && message) {
        ctx.save();
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = "#fdfbf6";
        const padding = 8;
        ctx.font = "15px system-ui, sans-serif";
        const w = ctx.measureText(message).width + padding * 2;
        const x = (canvas.width - w) / 2;
        const h = 30;
        const y2 = canvas.height * 0.12;
        ctx.fillRect(x, y2, w, h);
        ctx.strokeStyle = "#857d6a";
        ctx.strokeRect(x, y2, w, h);
        ctx.fillStyle = "#111";
        ctx.textBaseline = "middle";
        ctx.fillText(message, x + padding, y2 + h / 2);
        ctx.restore();
      }
    }

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawTiles();
      drawGrid();
      drawIntel();
      drawCrates();
      drawBarrels();
      drawGuardFOV();
      drawGuards();
      drawPlayer();
      drawExplosions();
      drawHUD();
    }

    // ===== Game loop =====
    let lastTime = 0;
    function gameLoop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      let dt = (timestamp - lastTime) / 1000;
      if (dt > 0.25) dt = 0.25;
      lastTime = timestamp;

      updateExplosions(dt);
      if (messageTimer > 0) {
        messageTimer -= dt;
        if (messageTimer <= 0) {
          messageTimer = 0;
          message = "";
        }
      }
      render();
      requestAnimationFrame(gameLoop);
    }

    // ===== Init =====
    resizeCanvas();
    resetLevel(true);
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
